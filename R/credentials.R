#' Create a file with email access credentials
#'
#' Create a file with access credentials for the purpose of more easily sending
#' email messages through [smtp_send()].
#'
#' @param filename An option to specify a name for the credentials file. If no
#'   name is provided, one will be automatically generated. The autogenerated
#'   file will be constructed in the following way: `blastula-v1-<host_name>`.
#' @param provider An optional email provider shortname for autocompleting STMP
#'   configuration details (the `host`, `port`, `use_ssl` options). Options
#'   currently include `gmail`, `outlook`, and `office365`. If nothing is
#'   provided then values for `host`, `port`, and `use_ssl` are expected.
#' @param user The username for the email account.
#' @param sender_name The sender name.
#' @param host The `host` name.
#' @param port The port number.
#' @param use_ssl An option as to whether to use SSL; supply a `TRUE` or `FALSE`
#'   value (`TRUE` is the default value).
#' @examples
#' \dontrun{
#' # Create a credentials file to make it
#' # much easier to send email out through
#' # Gmail with `smtp_send()`; call the
#' # credentials file "gmail_creds"
#' create_smtp_creds_file(
#'   filename = "gmail_creds",
#'   provider = "gmail"
#'   user = "user_name@gmail.com",
#'   )
#' }
#' @export
create_smtp_creds_file <- function(filename = NULL,
                                   provider = NULL,
                                   user,
                                   sender_name = NULL,
                                   host = NULL,
                                   port = NULL,
                                   use_ssl = TRUE) {

  # Create a credentials list from the function inputs
  credentials_list <-
    create_credentials_list(
      provider = provider,
      user = user,
      sender_name = sender_name,
      host = host,
      port = port,
      use_ssl = use_ssl
    )

  # Generate a file name
  file <- normalize_name(name = filename, host = credentials_list$host)

  # Create a plaintext JSON string for the credentials
  serialized <- JSONify_credentials(credentials_list)

  # Write the credential values into a plaintext file
  # that contains JSON
  writeLines(serialized, file)
  Sys.chmod(file, mode = "0600")

  # Issue a message stating that the file has been created
  message("The SMTP credentials file (`", file, "`) has been generated")
}

#' Retrieve metadata and authentication values from an on-disk credentials file
#'
#' @noRd
get_smtp_file_creds <- function(file_name = NULL) {

  # For the given `file_name`, read in the JSON
  # data and convert it into a list object
  readLines(file_name) %>%
    jsonlite::unserializeJSON()
}

#' Store SMTP credentials in the system's key-value store
#'
#' Set SMTP access credentials in the system-wide key-value store for the
#' purpose of more easily sending email messages through [smtp_send()]. Support
#' for setting keys through `create_smtp_creds_key()` is provided through the
#' \pkg{keyring} package.
#'
#' @param keyname An option to specify a name for the key in the system-wide
#'   key-value store. If no name is provided, one will be automatically
#'   generated. The autogenerated key name will be constructed in the following
#'   way: `blastula-v1-<host_name>`.
#' @inheritParams create_smtp_creds_file
#' @examples
#' \dontrun{
#' # Store SMTP crendentials using the
#' # system's secure key-value store to
#' # make it much easier to send email
#' # out through Gmail with `smtp_send()`;
#' # call the key "gmail_creds"
#' create_smtp_creds_key(
#'   keyname = "gmail_creds",
#'   provider = "gmail",
#'   user = "user_name@gmail.com",
#'   )
#' }
#' @export
create_smtp_creds_key <- function(keyname = NULL,
                                  provider = NULL,
                                  user,
                                  sender_name = NULL,
                                  host = NULL,
                                  port = NULL,
                                  use_ssl = TRUE) {

  # Determine whether {keyring} can be used
  is_keyring_capable()

  # Create a credentials list from the function inputs
  credentials_list <-
    create_credentials_list(
      provider = provider,
      user = user,
      sender_name = sender_name,
      host = host,
      port = port,
      use_ssl = use_ssl
    )

  # Create the `service_name` value for `keyring`
  service_name <- normalize_name(name = keyname, host = credentials_list$host)

  # Create a plaintext JSON string for the credentials
  serialized <- JSONify_credentials(credentials_list)

  # Set the key in the system's default keyring
  keyring::key_set_with_value(
    service = service_name,
    user = user,
    password = serialized
  )

  # Issue a message stating that the file has been created
  message("The system key store has been updated with the (`", service_name, "`) key.")
}

#' Utility function for obtaining keyring entries related to blastula creds
#'
#' @import keyring
#' @importFrom dplyr as_tibble filter mutate
#' @importFrom tidyr separate
#' @noRd
get_keyring_creds_table <- function(version = schema_version) {

  creds_tbl <-
    keyring::key_list() %>%
    dplyr::as_tibble() %>%
    dplyr::filter(grepl(paste0("blastula-v", version), service))

  if (nrow(creds_tbl) == 0) {

    empty_creds_tbl <-
      dplyr::tibble(
        key_name = NA_character_,
        version = NA_integer_,
        username = NA_character_
      )[-1, ]

    return(empty_creds_tbl)

  } else {

    creds_tbl <-
      creds_tbl %>%
      tidyr::separate(
        col = service,
        into = c("package", "version", "key_name"),
        sep = "-",
        remove = FALSE
      ) %>%
      dplyr::mutate(
        version = version %>%
          tidy_gsub("v", "") %>%
          as.integer()) %>%
      dplyr::select(service, key_name, version, username)
  }

  creds_tbl
}

#' Retrieve metadata and authentication values from keyring data
#'
#' @noRd
get_smtp_keyring_creds <- function(key_name = NULL) {

  # Get a filtered table of key and values that
  # are only those keys generated by the
  # `create_smtp_creds_key()` function
  blastula_keys_tbl <-
    get_keyring_creds_table() %>%
    dplyr::filter(
      key_name == key_name,
      version == schema_version
    )

  # If the given `key_name` doesn't correspond to an
  # entry in `blastula_keys_tbl`, stop the function with
  # an explanatory message
  if (nrow(blastula_keys_tbl) == 0) {
    stop("There is no blastula key that corresponds to the `key_name` of \"",
         key_name, "\".",
         call. = FALSE)
  }

  # For the given `key_name` get the key's stored value and
  # transform the JSON data to a list object
  blastula_keys_tbl %>%
    dplyr::pull(service) %>%
    keyring::key_get() %>%
    jsonlite::unserializeJSON()
}

#' Helpers for supplying SMTP credentials
#'
#' These helper functions, the credential helpers, are used to supply SMTP
#' configuration and authorization information for the [smtp_send()] function.
#' These helpers ([creds_file()], [creds_key()], and [creds()]) are to be used
#' expressly with the `credentials` argument of [smtp_send()]. The
#' [creds_file()] credential helper is used to point at a credentials file
#' stored on disk. We can create that file using the [create_smtp_creds_file()]
#' function. The [creds_key()] credential helper is truly somthing special. It
#' actually helps one obtain credentials that are stored in the system-wide
#' key-value store. The equally magical [create_smtp_creds_key()] function sets
#' that key. Using [creds()] allows for manual specification of SMTP
#' configuration and authentication within that helper function.
#'
#' @param file When using the [creds_file()] credential helper, we need to
#'   specify the location of the credential file, and, this is where that is
#'   done. The credential file was ideally generated by the
#'   [create_smtp_creds_file()] function.
#' @param key_name When using the [creds_key()] credential helper, the name of
#'   the key (in the system key-value store) needs to be given here. This was
#'   either explicitly provided when using the [create_smtp_creds_key()]
#'   function (with its own `key_name` argument), or, it may have been
#'   automatically generated based on the SMTP host name.
#' @inheritParams create_smtp_creds_file
#' @name credential_helpers
#' @return a list object of class `location_cells`.
NULL

#' Credentials helper for pointing to a SMTP credentials file
#'
#' @rdname credential_helpers
#' @export
creds_file <- function(file) {

  structure(
    class = c("creds_file", "blastula_creds"),
    list(
      file = file
    )
  )
}

#' Credentials helper for pointing to a SMTP credentials key
#'
#' @rdname credential_helpers
#' @export
creds_key <- function(key_name) {

  structure(
    class = c("creds_key", "blastula_creds"),
    list(
      key_name = key_name
    )
  )
}

#' Credentials helper for manual entry of SMTP config and auth values
#'
#' @rdname credential_helpers
#' @export
creds <- function(provider = NULL,
                  user,
                  sender_name = NULL,
                  host = NULL,
                  port = NULL,
                  use_ssl = TRUE) {

  # Create a credentials list from the function inputs
  credentials_list <-
    create_credentials_list(
      provider = provider,
      user = user,
      sender_name = sender_name,
      host = host,
      port = port,
      use_ssl = use_ssl
    )

  structure(
    class = c("creds", "blastula_creds"),
    credentials_list
  )
}

#' Create a credentials list object
#'
#' @noRd
create_credentials_list <- function(provider,
                                    user,
                                    sender_name,
                                    host,
                                    port,
                                    use_ssl) {

  # Ensure that `use_ssl` is either TRUE or FALSE
  if (!(use_ssl %in% c(TRUE, FALSE))) {
    stop("The value supplied to `use_ssl` must be TRUE or FALSE.")
  }

  # Prompt for the password using `getPass::getPass()`
  password <- getPass::getPass("Enter the SMTP server password: ")

  # If a `provider` name is given, extract values for `host`,
  # `port`, `use_ssl`, `use_tls`, and `authenticate`
  if (!is.null(provider) &&
      provider %in% (smtp_settings() %>% dplyr::pull(short_name))) {

    # Extract the record for the SMTP provider
    settings_record <-
      smtp_settings() %>%
      dplyr::filter(short_name == provider)

    # Extract settings for the provider
    if (is.null(host)) host <- settings_record$server
    if (is.null(port)) port <- settings_record$port
    if (is.null(use_ssl)) use_ssl <- settings_record$use_ssl
  }

  # Generate the credentials list
  list(
    version = schema_version,
    sender_name = sender_name,
    host = host,
    port = port,
    use_ssl = use_ssl,
    user = user,
    password = password
  )
}

#' Is keyring able to store keys?
#'
#' @noRd
is_keyring_capable <- function() {

  if (!keyring::has_keyring_support()) {
    stop("To store SMTP via *keyring*, the system needs to have",
         "*keyring* support", call. = FALSE)
  }
}

#' Convert a `credentials_list` to a JSON string
#'
#' @noRd
JSONify_credentials <- function(credentials_list) {

  # Create a plaintext JSON string for the credentials
  credentials_list %>%
    jsonlite::serializeJSON() %>%
    as.character()
}

#' Construct a name from a provided one or from a hostname
#'
#' @noRd
normalize_name <- function(name = NULL,
                           host) {

  if (is.null(name)) {

    # Construct a name based on the `host` name
    name <- paste0("blastula-v", schema_version, "-", host %>% tidy_gsub("\\.", "_"))

  } else {

    name <- as.character(name)
  }

  name
}

# Globally set the schema version for the storage
# of SMTP settings and authentication via keyring
schema_version <- 1L
